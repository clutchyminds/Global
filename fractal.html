<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Galerie Fractales Zoomables et Géométriques</title>
  <style>
    body { background: #222; color: #fff; font-family: Arial; text-align: center;}
    .container { max-width: 900px; margin: auto; }
    canvas { background: #000; border: 1px solid #888; margin: 16px 0; cursor: grab; }
    label, select { margin: 0 8px; }
    input { width: 60px; margin: 0 5px; }
    #inputs input { margin-bottom: 5px; }
  </style>
</head>
<body>
<div class="container">
  <h1>Grande Galerie des Fractales zoomables et classiques</h1>
  <select id="fractalType" onchange="updateInputs()"></select>
  <span id="inputs"></span>
  <span id="zoomLabelSpan">
    <label id="zoomLabelTxt">Zoom : <span id="zoomLabel">1</span></label>
  </span>
  <button onclick="draw(true)">Dessine !</button>
  <canvas id="fractalCanvas" width="600" height="600"></canvas>
</div>
<script>
const fractalList = [
  {id:"mandelbrot", name:"Mandelbrot"},
  {id:"julia", name:"Julia"},
  {id:"burning", name:"Burning Ship"},
  {id:"multibrot", name:"Multibrot"},
  {id:"phoenix", name:"Phoenix"},
  {id:"tricorn", name:"Tricorn (Mandelbar)"},
  {id:"perpmandel", name:"Perpendicular Mandelbrot"},
  {id:"celtic", name:"Celtic"},
  {id:"buffalo", name:"Buffalo"},
  {id:"perpbuffalo", name:"Perpendicular Buffalo"},
  {id:"heart", name:"Heart"},
  {id:"perpburn", name:"Perpendicular Burning Ship"},
  {id:"douady", name:"Douady Rabbit"},
  {id:"sierpinski", name:"Triangle Sierpinski"},
  {id:"koch", name:"Flocon de Koch"}
];

const selectHtml = fractalList.map(f=>`<option value="${f.id}">${f.name}</option>`).join("");
document.getElementById('fractalType').innerHTML = `<option value="">-- Sélectionner une fractale --</option>${selectHtml}`;

const canvas = document.getElementById('fractalCanvas');
const ctx = canvas.getContext('2d');
const inputsDiv = document.getElementById('inputs');
const zoomLabel = document.getElementById('zoomLabel');

let state = {};
fractalList.forEach(f=>{
  state[f.id] = { centerx: f.id==="burning"?-1.75:0, centery:0, zoom:1, dragging:false, dragStart:{x:0,y:0}, startCenter:{x:0,y:0}};
  if(f.id==="mandelbrot") state[f.id].centerx = -0.7;
  if(f.id==="douady") state[f.id].creal = -0.123; state[f.id].cimag = 0.745; // repère pour Douady
});

function updateInputs() {
  const type = document.getElementById('fractalType').value;
  let html = "";
  zoomLabel.textContent = state[type]?.zoom?.toFixed(3) || "1";
  // paramétrage plan complexe
  if(["mandelbrot","burning","tricorn","perpmandel","celtic","buffalo","perpbuffalo","heart","perpburn"].includes(type)){
    html = `
      <label>Itérations <input id="iterations" type="number" value="200" min="10" max="4000"></label>
      <label>Centre X <input id="centerx" type="number" value="${state[type].centerx}" step="0.001"></label>
      <label>Centre Y <input id="centery" type="number" value="${state[type].centery}" step="0.001"></label>
    `;
  }
  if(type==="multibrot"){
    html = `
      <label>Itérations <input id="iterations" type="number" value="180" min="10" max="4000"></label>
      <label>Expo <input id="expo" type="number" value="3" min="2" max="9"></label>
      <label>Centre X <input id="centerx" type="number" value="${state[type].centerx}" step="0.001"></label>
      <label>Centre Y <input id="centery" type="number" value="${state[type].centery}" step="0.001"></label>
    `;
  }
  if(type==="phoenix"){
    html = `
      <label>Itérations <input id="iterations" type="number" value="180" min="10" max="4000"></label>
      <label>Centre X <input id="centerx" type="number" value="${state[type].centerx}" step="0.001"></label>
      <label>Centre Y <input id="centery" type="number" value="${state[type].centery}" step="0.001"></label>
      <label>p <input id="p" type="number" value="-0.5" step="0.001"></label>
      <label>q <input id="q" type="number" value="-0.5" step="0.001"></label>
    `;
  }
  if(type==="julia"){
    html = `
      <label>Itérations <input id="iterations" type="number" value="180" min="10" max="4000"></label>
      <label>Centre X <input id="centerx" type="number" value="${state[type].centerx}" step="0.001"></label>
      <label>Centre Y <input id="centery" type="number" value="${state[type].centery}" step="0.001"></label>
      <label>c<sub>re</sub> <input id="creal" type="number" value="-0.8" step="0.001"></label>
      <label>c<sub>im</sub> <input id="cimag" type="number" value="0.156" step="0.001"></label>
    `;
  }
  if(type==="douady"){
    html = `
      <label>Itérations <input id="iterations" type="number" value="180" min="10" max="4000"></label>
      <label>Centre X <input id="centerx" type="number" value="0" step="0.001"></label>
      <label>Centre Y <input id="centery" type="number" value="0" step="0.001"></label>
      <label>c<sub>re</sub> <input id="creal" type="number" value="-0.123" step="0.001"></label>
      <label>c<sub>im</sub> <input id="cimag" type="number" value="0.745" step="0.001"></label>
    `;
  }
  // fractales géométriques
  if(type==="sierpinski"){
    html = `<label>Profondeur <input id="depth" type="number" value="6" min="1" max="12"></label>`;
  }
  if(type==="koch"){
    html = `<label>Profondeur <input id="depth" type="number" value="5" min="1" max="9"></label>`;
  }
  inputsDiv.innerHTML = html;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  draw(true);
}
document.getElementById('fractalType').addEventListener('change',updateInputs);

canvas.addEventListener('mousedown', function(e){
  const type = document.getElementById('fractalType').value;
  if(state[type]){
    state[type].dragging = true;
    state[type].dragStart = {x:e.offsetX, y:e.offsetY};
    state[type].startCenter = {x: state[type].centerx, y: state[type].centery};
    canvas.style.cursor = "grabbing";
  }
});
canvas.addEventListener('mouseup', function(e){
  const type = document.getElementById('fractalType').value;
  if(state[type]) state[type].dragging = false;
  canvas.style.cursor = "grab";
  draw(true);
});
canvas.addEventListener('mousemove', function(e){
  const type = document.getElementById('fractalType').value;
  if(state[type] && state[type].dragging && !["sierpinski","koch"].includes(type)){
    const w = canvas.width, h = canvas.height;
    const scale = 3.5 / state[type].zoom;
    const dx = e.offsetX - state[type].dragStart.x;
    const dy = e.offsetY - state[type].dragStart.y;
    state[type].centerx = state[type].startCenter.x - dx*scale/w;
    state[type].centery = state[type].startCenter.y - dy*scale/w;
    document.getElementById('centerx').value = state[type].centerx;
    document.getElementById('centery').value = state[type].centery;
    draw(false);
  }
});
canvas.addEventListener('wheel', function(e){
  const type = document.getElementById('fractalType').value;
  if(state[type] && !["sierpinski","koch"].includes(type)){
    e.preventDefault();
    const factor = e.deltaY<0 ? 1.18 : 1/1.18;
    state[type].zoom *= factor;
    zoomLabel.textContent = state[type].zoom.toFixed(3);
    draw(false);
  }
});

function draw(isFinal) {
  const type = document.getElementById('fractalType').value;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (!type) return;
  const iter = document.getElementById('iterations') ? parseInt(document.getElementById('iterations').value) : 180;
  const depth = document.getElementById('depth') ? parseInt(document.getElementById('depth').value) : 6;
  const expo = document.getElementById('expo') ? parseFloat(document.getElementById('expo').value) : 3;
  const creal = document.getElementById('creal') ? parseFloat(document.getElementById('creal').value) : null;
  const cimag = document.getElementById('cimag') ? parseFloat(document.getElementById('cimag').value) : null;
  const p = document.getElementById('p') ? parseFloat(document.getElementById('p').value) : -0.5;
  const q = document.getElementById('q') ? parseFloat(document.getElementById('q').value) : -0.5;

  // Plan complexe
  if(type==="mandelbrot") drawSet((z,c,n)=>mandelbrot(z,c,n), state[type], iter, isFinal);
  if(type==="julia") drawSet((z,c,n)=>julia(z,c,n), { ...state[type], creal, cimag }, iter, isFinal);
  if(type==="burning") drawSet((z,c,n)=>burningShip(z,c,n), state[type], iter, isFinal);
  if(type==="tricorn") drawSet((z,c,n)=>tricorn(z,c,n), state[type], iter, isFinal);
  if(type==="perpmandel") drawSet((z,c,n)=>perpmandel(z,c,n), state[type], iter, isFinal);
  if(type==="celtic") drawSet((z,c,n)=>celtic(z,c,n), state[type], iter, isFinal);
  if(type==="buffalo") drawSet((z,c,n)=>buffalo(z,c,n), state[type], iter, isFinal);
  if(type==="perpbuffalo") drawSet((z,c,n)=>perpbuffalo(z,c,n), state[type], iter, isFinal);
  if(type==="heart") drawSet((z,c,n)=>heart(z,c,n), state[type], iter, isFinal);
  if(type==="perpburn") drawSet((z,c,n)=>perpburn(z,c,n), state[type], iter, isFinal);
  if(type==="phoenix") drawSet((z,c,n)=>phoenix(z,c,n,p,q), state[type], iter, isFinal);
  if(type==="multibrot") drawSet((z,c,n)=>multibrot(z,c,n,expo), state[type], iter, isFinal);
  if(type==="douady") drawSet((z,c,n)=>julia(z,c,n), { ...state[type], creal, cimag }, iter, isFinal);

  // Fractales géométriques
  if(type==="sierpinski") drawSierpinski(depth);
  if(type==="koch") drawKoch(depth);
}

// ----- Fractales du plan complexe -----
function drawSet(fractal, st, iter, isFinal) {
  let w = canvas.width, h = canvas.height;
  let zoom = st.zoom;
  let centerx = st.centerx;
  let centery = st.centery;
  let creal = st.creal!==undefined ? st.creal : null;
  let cimag = st.cimag!==undefined ? st.cimag : null;
  let scale = 3.5 / zoom;
  let xmin = centerx - scale / 2;
  let xmax = centerx + scale / 2;
  let ymin = centery - scale * h / w / 2;
  let ymax = centery + scale * h / w / 2;
  const effectiveIter = isFinal ? iter : Math.min(iter,45);
  let imageData = ctx.createImageData(w, h);
  for (let px=0; px<w; px++) for (let py=0; py<h; py++) {
    let cx = xmin + (px/w) * (xmax-xmin);
    let cy = ymin + (py/h) * (ymax-ymin);
    let v = fractal({x:cx, y:cy}, {cre:creal, cim:cimag}, effectiveIter);
    let idx = (py*w+px)*4;
    let c = v === effectiveIter ? 0 : 255*Math.sqrt(v/effectiveIter);
    imageData.data[idx]=c; imageData.data[idx+1]=c*0.5; imageData.data[idx+2]=255-c; imageData.data[idx+3]=255;
  }
  ctx.putImageData(imageData,0,0);
  zoomLabel.textContent = zoom.toFixed(3);
}
// Algorithmes
function mandelbrot(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=2*x*y+z.y; x=xt;i++;} return i;}
function julia(z,c,n){ let x=z.x,y=z.y,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+(c.cre??-0.8); y=2*x*y+(c.cim??0.156); x=xt;i++;} return i;}
function burningShip(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=Math.abs(2*x*y)+z.y; x=Math.abs(xt);i++;} return i;}
function tricorn(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=-2*x*y+z.y; x=xt;i++;} return i;}
function perpmandel(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=-2*Math.abs(x*y)+z.y;x=xt;i++;} return i;}
function celtic(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=Math.abs(x*x-y*y)+z.x; y=2*x*y+z.y;x=xt;i++;} return i;}
function buffalo(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=Math.abs(x*x-y*y)+z.x; y=-2*Math.abs(x*y)+z.y;x=xt;i++;} return i;}
function perpbuffalo(z,_,n){let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=Math.abs(x*x-y*y)+z.x; y=-2*x*y+z.y;x=xt;i++;}return i;}
function heart(z,_,n){ let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=Math.abs(2*x*y)+z.y;x=xt;i++;}return i;}
function perpburn(z,_,n){let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x; y=-2*Math.abs(x*y)+z.y;x=Math.abs(xt);i++;}return i;}
function phoenix(z,_,p,q,n){let x=0,y=0,xo=0,yo=0,i=0; while(x*x+y*y<=4&&i<n){let xt=x*x-y*y+z.x+p*xo+q*yo; let yt=2*x*y+z.y+p*yo+q*xo; xo=x;yo=y;x=xt;y=yt;i++;}return i;}
function multibrot(z,_,expo,n){let x=0,y=0,i=0; while(x*x+y*y<=4&&i<n){let r=Math.pow(x*x+y*y,expo/2); let th=Math.atan2(y,x)*expo; let xt=r*Math.cos(th)+z.x; let yt=r*Math.sin(th)+z.y;x=xt;y=yt;i++;}return i;}

// Fractales géométriques
function drawSierpinski(depth) {
  let w=canvas.width,h=canvas.height;
  function sierpinski(x,y,size,d){
    if(d===0){ ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x+size/2,y+size*Math.sqrt(3)/2);ctx.lineTo(x-size/2,y+size*Math.sqrt(3)/2);ctx.closePath();ctx.fillStyle="#53f";ctx.fill();return; }
    sierpinski(x, y, size/2, d-1);
    sierpinski(x-size/4, y+size*Math.sqrt(3)/4, size/2, d-1);
    sierpinski(x+size/4, y+size*Math.sqrt(3)/4, size/2, d-1);
  }
  sierpinski(w/2, 30, w*0.8, depth);
}
function drawKoch(depth){
  let w=canvas.width,h=canvas.height;
  function koch(x1,y1,x2,y2,d){
    if(d===0){ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);return;}
    let dx=(x2-x1)/3,dy=(y2-y1)/3;
    let xA=x1+dx, yA=y1+dy;
    let xB=x1+2*dx, yB=y1+2*dy;
    let mx = (xA+xB)/2 + (Math.sqrt(3)/6)*(yA-yB);
    let my = (yA+yB)/2 + (Math.sqrt(3)/6)*(xB-xA);
    koch(x1, y1, xA, yA, d-1); koch(xA, yA, mx, my, d-1); koch(mx, my, xB, yB, d-1); koch(xB, yB, x2, y2, d-1);
  }
  ctx.beginPath();
  let size = w*0.7, h0 = h*0.7;
  let x1=w/2-size/2, y1=h0;
  let x2=w/2+size/2, y2=h0;
  let x3=w/2, y3=h0-size*Math.sqrt(3)/2;
  koch(x1,y1, x2,y2, depth);
  koch(x2,y2, x3,y3, depth);
  koch(x3,y3, x1,y1, depth);
  ctx.strokeStyle="#5ff";
  ctx.stroke();
}

canvas.addEventListener('mouseup',()=>draw(true));
["mouseup","touchend"].forEach(ev=>canvas.addEventListener(ev,()=>draw(true)));
inputsDiv.addEventListener('input', function(e) { draw(true); });
updateInputs();
</script>
</body>
</html>
